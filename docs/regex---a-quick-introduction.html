<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>Chapter 29 Regex - A quick introduction | R for Audit Analytics</title>

    <meta name="author" content="Anil Goyal" />
  
   <meta name="description" content="This book is intended for auditors performing exploratory data analytics using R programming language, mainly Base R and Tidyverse." />
   <meta name="generator" content="placeholder" />
  <meta property="og:title" content="Chapter 29 Regex - A quick introduction | R for Audit Analytics" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://anilyayavar.github.io/new-book/" />
  <meta property="og:image" content="https://anilyayavar.github.io/new-book/images/cover.jpg" />
  <meta property="og:description" content="This book is intended for auditors performing exploratory data analytics using R programming language, mainly Base R and Tidyverse." />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 29 Regex - A quick introduction | R for Audit Analytics" />
  
  <meta name="twitter:description" content="This book is intended for auditors performing exploratory data analytics using R programming language, mainly Base R and Tidyverse." />
  <meta name="twitter:image" content="https://anilyayavar.github.io/new-book/images/cover.jpg" />
  <!-- JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script>
  <script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script>
    <script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet" />
    <script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script>
    <script src="libs/bs3compat-0.8.0/transition.js"></script>
    <script src="libs/bs3compat-0.8.0/tabs.js"></script>
    <script src="libs/bs3compat-0.8.0/bs3compat.js"></script>
    <link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet" />
    <script src="libs/bs4_book-1.0.0/bs4_book.js"></script>
    <script src="libs/kePrint-0.0.1/kePrint.js"></script>
    <link href="libs/lightable-0.0.1/lightable.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script>

  <!-- CSS -->
  <style type="text/css">
    
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  </style>
    <style type="text/css">
    /* Used with Pandoc 2.11+ new --citeproc when CSL is used */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
          margin-bottom: 0em;
        }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
      <link rel="stylesheet" href="style.css" />
  
</head>

<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book">
    <a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">R for Audit Analytics</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
      </form>

      <nav aria-label="Table of contents">
        <h2>Table of contents</h2>
        <div id="book-toc"></div>

        <div class="book-extra">
          <p><a id="book-repo" href="#">View book source <i class="fab fa-github"></i></a></li></p>
        </div>
      </nav>
    </div>
  </header>

  <main class="col-sm-12 col-md-9 col-lg-7" id="content">
<div id="regex---a-quick-introduction" class="section level1" number="29">
<h1><span class="header-section-number">Chapter 29</span> Regex - A quick introduction</h1>
<p>A <strong>Regular Expression</strong>, or <strong>regex</strong> for short, is a powerful tool, which helps us writing code for pattern matching in texts. Regex, is a pattern that describes a set of strings. It is a sequence of characters that define a search pattern. It is used to search for and manipulate text. Regex can be used in many programming languages, including R.</p>
<p>Regex patterns are made up of a combination of regular characters and special characters. Regular characters include letters, digits, and punctuation marks. Special characters have a specific meaning in regex and are used to represent patterns of characters.</p>
<p>Regex patterns can be used for a variety of purposes, including:</p>
<ul>
<li>Searching for specific strings in text</li>
<li>Extracting specific parts of a string</li>
<li>Replacing parts of a string with other text</li>
<li>Validating input from users</li>
</ul>
<p>In R, we can use the <code>grep</code> and <code>gsub</code> functions to search for and manipulate text using regex.</p>
<div id="basic-regex---literal-characters" class="section level2" number="29.1">
<h2><span class="header-section-number">29.1</span> Basic Regex - Literal Characters</h2>
<p>Every <em>literal character</em>, in itself is a <code>regex</code> that matches itself. Thus, <code>a</code> matches third character in text <code>Charles</code>. These literal characters are case sensitive.</p>
<p>Example-1</p>
<div class="sourceCode" id="cb1680"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1680-1"><a href="regex---a-quick-introduction.html#cb1680-1" tabindex="-1"></a>ex_text <span class="ot">&lt;-</span> <span class="st">&quot;This is an example text&quot;</span></span>
<span id="cb1680-2"><a href="regex---a-quick-introduction.html#cb1680-2" tabindex="-1"></a><span class="co"># Match literal `x`</span></span>
<span id="cb1680-3"><a href="regex---a-quick-introduction.html#cb1680-3" tabindex="-1"></a><span class="fu">str_view</span>(ex_text, <span class="st">&quot;x&quot;</span>)</span></code></pre></div>
<pre><code>## [1] │ This is an e&lt;x&gt;ample te&lt;x&gt;t</code></pre>
<div class="sourceCode" id="cb1682"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1682-1"><a href="regex---a-quick-introduction.html#cb1682-1" tabindex="-1"></a><span class="co"># Match Upper case literal &quot;X&quot;</span></span>
<span id="cb1682-2"><a href="regex---a-quick-introduction.html#cb1682-2" tabindex="-1"></a><span class="fu">str_view</span>(ex_text, <span class="st">&quot;X&quot;</span>, <span class="at">match =</span> <span class="cn">NA</span>)</span></code></pre></div>
<pre><code>## [1] │ This is an example text</code></pre>
<div id="case-sensitivity" class="section level3" number="29.1.1">
<h3><span class="header-section-number">29.1.1</span> Case sensitivity</h3>
<p>As the literals are case_sensitive and we sometimes are not aware of exact case, to match case insensitive literals, we can make use of <code>stringr</code> function <code>regex</code> in this case, wherein an argument <code>ignore_case</code> (note snake case) is there. Actually, behind the scenes, all regex expressions in stringr are wrapped in this function with argument defaults as <code>FALSE</code>. Thus, the code in above example is actually equivalent to the following-</p>
<div class="sourceCode" id="cb1684"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1684-1"><a href="regex---a-quick-introduction.html#cb1684-1" tabindex="-1"></a><span class="co"># Match literal `x`</span></span>
<span id="cb1684-2"><a href="regex---a-quick-introduction.html#cb1684-2" tabindex="-1"></a><span class="fu">str_view</span>(ex_text, <span class="fu">regex</span>(<span class="st">&quot;x&quot;</span>))</span></code></pre></div>
<pre><code>## [1] │ This is an e&lt;x&gt;ample te&lt;x&gt;t</code></pre>
<div class="sourceCode" id="cb1686"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1686-1"><a href="regex---a-quick-introduction.html#cb1686-1" tabindex="-1"></a><span class="co"># Match Upper case literal &quot;X&quot;</span></span>
<span id="cb1686-2"><a href="regex---a-quick-introduction.html#cb1686-2" tabindex="-1"></a><span class="fu">str_view</span>(ex_text, <span class="fu">regex</span>(<span class="st">&quot;X&quot;</span>), <span class="at">match =</span> <span class="cn">NA</span>)</span></code></pre></div>
<pre><code>## [1] │ This is an example text</code></pre>
<p>Thus, to match case insensitive literals (or other regex expressions) we may make use of the argument <code>ignore_case</code> like this-</p>
<div class="sourceCode" id="cb1688"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1688-1"><a href="regex---a-quick-introduction.html#cb1688-1" tabindex="-1"></a><span class="co"># Match literal `x`</span></span>
<span id="cb1688-2"><a href="regex---a-quick-introduction.html#cb1688-2" tabindex="-1"></a><span class="fu">str_view</span>(ex_text, <span class="fu">regex</span>(<span class="st">&quot;X&quot;</span>, <span class="at">ignore_case =</span> <span class="cn">TRUE</span>))</span></code></pre></div>
<pre><code>## [1] │ This is an e&lt;x&gt;ample te&lt;x&gt;t</code></pre>
</div>
</div>
<div id="metacharacters" class="section level2" number="29.2">
<h2><span class="header-section-number">29.2</span> Metacharacters</h2>
<div id="character-sets" class="section level3" number="29.2.1">
<h3><span class="header-section-number">29.2.1</span> Character sets</h3>
<p>It is always not feasible to put every literal characters. We may also match literal characters from a given set of options. To <strong>match a group of characters</strong> we have to put all these in square brackets. So, <code>[abc]</code> matches either of <code>a</code>, <code>b</code>, or <code>c</code>.</p>
<p>Example-</p>
<div class="sourceCode" id="cb1690"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1690-1"><a href="regex---a-quick-introduction.html#cb1690-1" tabindex="-1"></a>ex_vec <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;Apple&quot;</span>, <span class="st">&quot;Orange&quot;</span>, <span class="st">&quot;Myrrh&quot;</span>)</span>
<span id="cb1690-2"><a href="regex---a-quick-introduction.html#cb1690-2" tabindex="-1"></a><span class="co"># matches a vowel</span></span>
<span id="cb1690-3"><a href="regex---a-quick-introduction.html#cb1690-3" tabindex="-1"></a><span class="fu">str_view</span>(ex_vec, <span class="st">&quot;[aeiou]&quot;</span>)</span></code></pre></div>
<pre><code>## [1] │ Appl&lt;e&gt;
## [2] │ Or&lt;a&gt;ng&lt;e&gt;</code></pre>
<div class="sourceCode" id="cb1692"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1692-1"><a href="regex---a-quick-introduction.html#cb1692-1" tabindex="-1"></a><span class="co"># matches a vowel irrespective of case</span></span>
<span id="cb1692-2"><a href="regex---a-quick-introduction.html#cb1692-2" tabindex="-1"></a><span class="fu">str_view</span>(ex_vec, <span class="fu">regex</span>(<span class="st">&quot;[aeiou]&quot;</span>, <span class="at">ignore_case =</span> <span class="cn">TRUE</span>))</span></code></pre></div>
<pre><code>## [1] │ &lt;A&gt;ppl&lt;e&gt;
## [2] │ &lt;O&gt;r&lt;a&gt;ng&lt;e&gt;</code></pre>
<p>To <strong>match a range of characters/numbers</strong> we can separate these by hyphen in square brackets. So, <code>[a-n]</code> will match a character from range <code>[abcdefghijklmn]</code>.</p>
<p>Example-</p>
<div class="sourceCode" id="cb1694"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1694-1"><a href="regex---a-quick-introduction.html#cb1694-1" tabindex="-1"></a>ex_text <span class="ot">&lt;-</span> <span class="st">&quot;The quick brown fox jumps over the lazy dog&quot;</span></span>
<span id="cb1694-2"><a href="regex---a-quick-introduction.html#cb1694-2" tabindex="-1"></a><span class="co"># Match a, b or c in lower case</span></span>
<span id="cb1694-3"><a href="regex---a-quick-introduction.html#cb1694-3" tabindex="-1"></a><span class="fu">str_view</span>(ex_text, <span class="fu">regex</span>(<span class="st">&quot;[a-c]&quot;</span>))</span></code></pre></div>
<pre><code>## [1] │ The qui&lt;c&gt;k &lt;b&gt;rown fox jumps over the l&lt;a&gt;zy dog</code></pre>
<p>Example-2</p>
<div class="sourceCode" id="cb1696"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1696-1"><a href="regex---a-quick-introduction.html#cb1696-1" tabindex="-1"></a>ex_colors <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;grey&quot;</span>, <span class="st">&quot;black&quot;</span>, <span class="st">&quot;gray&quot;</span>)</span>
<span id="cb1696-2"><a href="regex---a-quick-introduction.html#cb1696-2" tabindex="-1"></a><span class="fu">str_view</span>(ex_colors, <span class="st">&quot;gr[ae]y&quot;</span>)</span></code></pre></div>
<pre><code>## [1] │ &lt;grey&gt;
## [3] │ &lt;gray&gt;</code></pre>
<p>We can also use <strong>pre-built character classes</strong> listed below.</p>
<ul>
<li><code>[:punct:]</code> punctuation.</li>
<li><code>[:alpha:]</code> letters.</li>
<li><code>[:lower:]</code> lowercase letters.</li>
<li><code>[:upper:]</code> uppercase letters.</li>
<li><code>[:digit:]</code> digits.</li>
<li><code>[:xdigit:]</code> hex digits.</li>
<li><code>[:alnum:]</code> letters and numbers.</li>
<li><code>[:cntrl:]</code> control characters.</li>
<li><code>[:graph:]</code> letters, numbers, and punctuation.</li>
<li><code>[:print:]</code> letters, numbers, punctuation, and white-space.</li>
<li><code>[:space:]</code> space characters (basically equivalent to <code>\\s</code>).</li>
<li><code>[:blank:]</code> space and tab.</li>
</ul>
<p>Example-</p>
<div class="sourceCode" id="cb1698"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1698-1"><a href="regex---a-quick-introduction.html#cb1698-1" tabindex="-1"></a>ex_vec2 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;One apple&quot;</span>, <span class="st">&quot;2 Oranges&quot;</span>)</span>
<span id="cb1698-2"><a href="regex---a-quick-introduction.html#cb1698-2" tabindex="-1"></a><span class="fu">str_view</span>(ex_vec2, <span class="st">&quot;[:digit:]&quot;</span>, <span class="at">match =</span> <span class="cn">NA</span>)</span></code></pre></div>
<pre><code>## [1] │ One apple
## [2] │ &lt;2&gt; Oranges</code></pre>
</div>
<div id="non-printable-characters-meta-characters-short-hand-character-classes" class="section level3" number="29.2.2">
<h3><span class="header-section-number">29.2.2</span> Non-printable characters/ Meta characters (short-hand character classes)</h3>
<p>We can use special character sequences to put non-printable characters in our regular expression(s). E.g. <code>\t</code> matches a tab character. <strong>But since <code>\</code> is an escape character in R, we need to escape it too.</strong> So to match a tab character we have to put <code>\\t</code> in our regex sequence. Regex for that matches new line (line feed) is <code>\\n</code>. <code>Regex</code> for other meta characters is listed below-</p>
<ul>
<li><code>\\s</code> matches a white-space character. Moreover, its complement <code>\\S</code> matches any character except a white-space.</li>
<li><code>\\w</code> matches any alphanumeric character. Similarly, its complement is <code>\\W</code> which matches any character except alphanumeric characters.</li>
<li><code>\\d</code> matches any digit. Similarly, its complement is <code>\\D</code> which matches any character except digits.</li>
<li><code>\\b</code> matches any word boundary. Thus, <code>\\B</code> matches any character except a word boundary.</li>
<li><code>.</code> matches any character. To match a literal dot <code>.</code> we have to escape that; and thus <code>\\.</code> matches a dot character.</li>
</ul>
<p>See these examples-</p>
<div class="sourceCode" id="cb1700"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1700-1"><a href="regex---a-quick-introduction.html#cb1700-1" tabindex="-1"></a>ex_vec3 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;One apple&quot;</span>, <span class="st">&quot;2 oranges &amp; 3 bananas.&quot;</span>)</span>
<span id="cb1700-2"><a href="regex---a-quick-introduction.html#cb1700-2" tabindex="-1"></a><span class="co"># match word character</span></span>
<span id="cb1700-3"><a href="regex---a-quick-introduction.html#cb1700-3" tabindex="-1"></a><span class="fu">str_view</span>(ex_vec3, <span class="st">&quot;</span><span class="sc">\\</span><span class="st">w&quot;</span>, <span class="at">match =</span> <span class="cn">NA</span>)</span></code></pre></div>
<pre><code>## [1] │ &lt;O&gt;&lt;n&gt;&lt;e&gt; &lt;a&gt;&lt;p&gt;&lt;p&gt;&lt;l&gt;&lt;e&gt;
## [2] │ &lt;2&gt; &lt;o&gt;&lt;r&gt;&lt;a&gt;&lt;n&gt;&lt;g&gt;&lt;e&gt;&lt;s&gt; &amp; &lt;3&gt; &lt;b&gt;&lt;a&gt;&lt;n&gt;&lt;a&gt;&lt;n&gt;&lt;a&gt;&lt;s&gt;.</code></pre>
<div class="sourceCode" id="cb1702"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1702-1"><a href="regex---a-quick-introduction.html#cb1702-1" tabindex="-1"></a><span class="co"># match any character followed by a dot character</span></span>
<span id="cb1702-2"><a href="regex---a-quick-introduction.html#cb1702-2" tabindex="-1"></a><span class="fu">str_view</span>(ex_vec3, <span class="st">&quot;.</span><span class="sc">\\</span><span class="st">.&quot;</span>, <span class="at">match =</span> <span class="cn">NA</span>)</span></code></pre></div>
<pre><code>## [1] │ One apple
## [2] │ 2 oranges &amp; 3 banana&lt;s.&gt;</code></pre>
<div class="sourceCode" id="cb1704"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1704-1"><a href="regex---a-quick-introduction.html#cb1704-1" tabindex="-1"></a><span class="co"># Note both character and dot will be matched</span></span></code></pre></div>
</div>
</div>
<div id="quantifiers" class="section level2" number="29.3">
<h2><span class="header-section-number">29.3</span> Quantifiers</h2>
<p>What if we want to match more than one literal/character through <code>regex</code>? Let’s say if we want to check whether the given string or string vector contain two consecutive vowels. One method may be to use character classes two times i.e. using <code>[aeiou][aeiou]</code>. But this method is against the principles of <strong>DRY</strong><a href="#fn35" class="footnote-ref" id="fnref35"><sup>35</sup></a> which is one of the common principle of programming. To solve these issues, we have quantifiers.</p>
<ul>
<li><code>+</code> <strong>1 or more</strong> occurrences</li>
<li><code>*</code> <strong>0 or more</strong></li>
<li><code>?</code> <strong>0 or 1</strong></li>
<li><code>{}</code> specified numbers
<ul>
<li><code>{n}</code> exactly n</li>
<li><code>{n,}</code> n or more</li>
<li><code>{n,m}</code> between n and m</li>
</ul></li>
</ul>
<p>Thus, we may match two consecutive vowels using <code>[aeiou]{2}</code>. See this example</p>
<div class="sourceCode" id="cb1705"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1705-1"><a href="regex---a-quick-introduction.html#cb1705-1" tabindex="-1"></a>ex_vec <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;Apple&quot;</span>, <span class="st">&quot;Banana&quot;</span>, <span class="st">&quot;pineapple&quot;</span>)</span>
<span id="cb1705-2"><a href="regex---a-quick-introduction.html#cb1705-2" tabindex="-1"></a><span class="fu">str_view</span>(ex_vec, <span class="st">&quot;[aeiou]{2}&quot;</span>, <span class="at">match =</span> <span class="cn">NA</span>)</span></code></pre></div>
<pre><code>## [1] │ Apple
## [2] │ Banana
## [3] │ pin&lt;ea&gt;pple</code></pre>
</div>
<div id="alternation" class="section level2" number="29.4">
<h2><span class="header-section-number">29.4</span> Alternation</h2>
<p>Alternation in regular expressions allows you to match one pattern or another, depending on which one appears first in the input string. The pipe symbol <code>|</code> is used to separate the alternative patterns.</p>
<div id="basic-alternation" class="section level5" number="29.4.0.0.1">
<h5><span class="header-section-number">29.4.0.0.1</span> Basic Alternation</h5>
<p>Let’s start with a basic example to illustrate how alternation works:</p>
<div class="sourceCode" id="cb1707"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1707-1"><a href="regex---a-quick-introduction.html#cb1707-1" tabindex="-1"></a>string <span class="ot">&lt;-</span> <span class="st">&quot;I have an apple and a banana&quot;</span></span>
<span id="cb1707-2"><a href="regex---a-quick-introduction.html#cb1707-2" tabindex="-1"></a>pattern <span class="ot">&lt;-</span> <span class="st">&quot;apple|banana&quot;</span></span>
<span id="cb1707-3"><a href="regex---a-quick-introduction.html#cb1707-3" tabindex="-1"></a></span>
<span id="cb1707-4"><a href="regex---a-quick-introduction.html#cb1707-4" tabindex="-1"></a><span class="fu">str_extract</span>(string, pattern)</span></code></pre></div>
<pre><code>## [1] &quot;apple&quot;</code></pre>
</div>
<div id="order-of-precedence" class="section level5" number="29.4.0.0.2">
<h5><span class="header-section-number">29.4.0.0.2</span> Order of Precedence</h5>
<p>When using alternation, it’s important to keep in mind the order of precedence rules. In general, the first pattern that matches the input string will be selected, and subsequent patterns will not be considered. Here’s an example to illustrate this:</p>
<div class="sourceCode" id="cb1709"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1709-1"><a href="regex---a-quick-introduction.html#cb1709-1" tabindex="-1"></a>string <span class="ot">&lt;-</span> <span class="st">&quot;I have a pineapple and an apple&quot;</span></span>
<span id="cb1709-2"><a href="regex---a-quick-introduction.html#cb1709-2" tabindex="-1"></a><span class="fu">str_extract</span>(string, <span class="at">pattern =</span> <span class="st">&quot;apple|pineapple&quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;pineapple&quot;</code></pre>
<p>In this example, we have a string <code>string</code> that contains the words “apple” and “pineapple”. We want to extract the first occurrence of either “apple” or “pineapple” from this text using a regular expression pattern that utilizes alternation. The pattern <code>apple|pineapple</code> means “match ‘apple’ OR ‘pineapple’”. However, since the input string contains “pineapple” before “apple”, the <code>str_extract()</code> function selects the first matching string “pineapple”.</p>
</div>
<div id="grouping-alternatives" class="section level5" number="29.4.0.0.3">
<h5><span class="header-section-number">29.4.0.0.3</span> Grouping Alternatives</h5>
<p>We can also use parentheses to group alternative patterns together. This can be useful for specifying more complex patterns. Example:</p>
<div class="sourceCode" id="cb1711"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1711-1"><a href="regex---a-quick-introduction.html#cb1711-1" tabindex="-1"></a>string <span class="ot">&lt;-</span> <span class="st">&quot;Apple and pineapples are good for health&quot;</span></span>
<span id="cb1711-2"><a href="regex---a-quick-introduction.html#cb1711-2" tabindex="-1"></a>pattern <span class="ot">&lt;-</span> <span class="st">&quot;(apple|banana|cherry) (and|or) (pineapple|kiwi|mango)&quot;</span></span>
<span id="cb1711-3"><a href="regex---a-quick-introduction.html#cb1711-3" tabindex="-1"></a></span>
<span id="cb1711-4"><a href="regex---a-quick-introduction.html#cb1711-4" tabindex="-1"></a><span class="fu">str_view</span>(string, <span class="fu">regex</span>(pattern, <span class="at">ignore_case =</span> <span class="cn">TRUE</span>))</span></code></pre></div>
<pre><code>## [1] │ &lt;Apple and pineapple&gt;s are good for health</code></pre>
<p>In above examples, we have used <code>stringr::regex()</code> to modify regex flag to ignore cases while matching.</p>
</div>
</div>
<div id="anchors" class="section level2" number="29.5">
<h2><span class="header-section-number">29.5</span> Anchors</h2>
<p>Anchors in regular expressions allow you to match patterns at specific positions within the input string. In R, you can use various anchors in your regular expressions to match the beginning, end, or specific positions within the input text.</p>
<div id="beginning-and-end-anchors" class="section level3" number="29.5.1">
<h3><span class="header-section-number">29.5.1</span> Beginning and End Anchors</h3>
<p>The beginning anchor <code>^</code> and end anchor <code>$</code> are used to match patterns at the beginning or end of the input string, respectively. Example</p>
<div class="sourceCode" id="cb1713"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1713-1"><a href="regex---a-quick-introduction.html#cb1713-1" tabindex="-1"></a>string <span class="ot">&lt;-</span> <span class="st">&quot;The quick brown fox jumps over the lazy dog. The fox is brown.&quot;</span></span>
<span id="cb1713-2"><a href="regex---a-quick-introduction.html#cb1713-2" tabindex="-1"></a>pattern <span class="ot">&lt;-</span> <span class="st">&quot;^the&quot;</span></span>
<span id="cb1713-3"><a href="regex---a-quick-introduction.html#cb1713-3" tabindex="-1"></a><span class="fu">str_view</span>(string, <span class="fu">regex</span>(pattern, <span class="at">ignore_case =</span> <span class="cn">TRUE</span>))</span></code></pre></div>
<pre><code>## [1] │ &lt;The&gt; quick brown fox jumps over the lazy dog. The fox is brown.</code></pre>
<p>In the above example, we are matching word <code>the</code> which is at the beginning of a sentence only.</p>
</div>
<div id="word-boundary-anchors" class="section level3" number="29.5.2">
<h3><span class="header-section-number">29.5.2</span> Word Boundary Anchors</h3>
<p>The word boundary anchor <code>\\b</code> is used to match patterns at the beginning or end of a word within the input string. Example</p>
<div class="sourceCode" id="cb1715"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1715-1"><a href="regex---a-quick-introduction.html#cb1715-1" tabindex="-1"></a>string <span class="ot">&lt;-</span> <span class="st">&#39;Apple and pineapple, both are good for health&#39;</span></span>
<span id="cb1715-2"><a href="regex---a-quick-introduction.html#cb1715-2" tabindex="-1"></a>pattern <span class="ot">&lt;-</span> <span class="st">&#39;</span><span class="sc">\\</span><span class="st">bapple</span><span class="sc">\\</span><span class="st">b&#39;</span></span>
<span id="cb1715-3"><a href="regex---a-quick-introduction.html#cb1715-3" tabindex="-1"></a><span class="fu">str_view</span>(string, <span class="fu">regex</span>(pattern, <span class="at">ignore_case =</span> <span class="cn">TRUE</span>))</span></code></pre></div>
<pre><code>## [1] │ &lt;Apple&gt; and pineapple, both are good for health</code></pre>
<p>In the above example, though <code>apple</code> string is contained in another word <code>pineapple</code> we are limiting our search for whole words only.</p>
</div>
</div>
<div id="capture-groups" class="section level2" number="29.6">
<h2><span class="header-section-number">29.6</span> Capture Groups</h2>
<p>A capture group is a way to group a part of a regular expression and capture it as a separate sub-string. This can be useful when you want to extract or replace a specific part of a string. In R, capture groups are denoted by parentheses <code>()</code>. Anything inside the parentheses is captured and can be referenced later in the regular expression or in the replacement string.</p>
<p>One use of capturing group is to refer back to it within a match with back reference: <code>\1</code> refers to the match contained in the first parenthesis, <code>\2</code> in the second parenthesis, and so on.</p>
<p>Example-1</p>
<div class="sourceCode" id="cb1717"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1717-1"><a href="regex---a-quick-introduction.html#cb1717-1" tabindex="-1"></a>my_fruits <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&#39;apple&#39;</span>, <span class="st">&#39;banana&#39;</span>, <span class="st">&#39;coconut&#39;</span>, <span class="st">&#39;berry&#39;</span>, <span class="st">&#39;cucumber&#39;</span>, <span class="st">&#39;date&#39;</span>)</span>
<span id="cb1717-2"><a href="regex---a-quick-introduction.html#cb1717-2" tabindex="-1"></a><span class="co"># search for repeated alphabet</span></span>
<span id="cb1717-3"><a href="regex---a-quick-introduction.html#cb1717-3" tabindex="-1"></a>pattern <span class="ot">&lt;-</span> <span class="st">&#39;(.)</span><span class="sc">\\</span><span class="st">1&#39;</span></span>
<span id="cb1717-4"><a href="regex---a-quick-introduction.html#cb1717-4" tabindex="-1"></a><span class="fu">str_view</span>(my_fruits, <span class="fu">regex</span>(pattern), <span class="at">match =</span> <span class="cn">NA</span>)</span></code></pre></div>
<pre><code>## [1] │ a&lt;pp&gt;le
## [2] │ banana
## [3] │ coconut
## [4] │ be&lt;rr&gt;y
## [5] │ cucumber
## [6] │ date</code></pre>
<p>Example-2</p>
<div class="sourceCode" id="cb1719"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1719-1"><a href="regex---a-quick-introduction.html#cb1719-1" tabindex="-1"></a><span class="co"># search for repeated pair of alphabets</span></span>
<span id="cb1719-2"><a href="regex---a-quick-introduction.html#cb1719-2" tabindex="-1"></a>pattern <span class="ot">&lt;-</span> <span class="st">&#39;(..)</span><span class="sc">\\</span><span class="st">1&#39;</span></span>
<span id="cb1719-3"><a href="regex---a-quick-introduction.html#cb1719-3" tabindex="-1"></a><span class="fu">str_view</span>(my_fruits, <span class="fu">regex</span>(pattern), <span class="at">match =</span> <span class="cn">NA</span>)</span></code></pre></div>
<pre><code>## [1] │ apple
## [2] │ b&lt;anan&gt;a
## [3] │ &lt;coco&gt;nut
## [4] │ berry
## [5] │ &lt;cucu&gt;mber
## [6] │ date</code></pre>
<p>Another way to use capturing group is, when we want to replace the pattern with something else. It is better to understand this with the following example-</p>
<div class="sourceCode" id="cb1721"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1721-1"><a href="regex---a-quick-introduction.html#cb1721-1" tabindex="-1"></a><span class="co"># We have names in last_name, first_name format</span></span>
<span id="cb1721-2"><a href="regex---a-quick-introduction.html#cb1721-2" tabindex="-1"></a>names <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&#39;Hanks, Tom&#39;</span>, <span class="st">&#39;Affleck, Ben&#39;</span>, <span class="st">&#39;Damon, Matt&#39;</span>)</span>
<span id="cb1721-3"><a href="regex---a-quick-introduction.html#cb1721-3" tabindex="-1"></a><span class="fu">str_view</span>(names)</span></code></pre></div>
<pre><code>## [1] │ Hanks, Tom
## [2] │ Affleck, Ben
## [3] │ Damon, Matt</code></pre>
<div class="sourceCode" id="cb1723"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1723-1"><a href="regex---a-quick-introduction.html#cb1723-1" tabindex="-1"></a><span class="co"># Using this regex, we can convert these to first_name last_name format</span></span>
<span id="cb1723-2"><a href="regex---a-quick-introduction.html#cb1723-2" tabindex="-1"></a><span class="fu">str_replace_all</span>(names, <span class="st">&#39;(</span><span class="sc">\\</span><span class="st">w+),</span><span class="sc">\\</span><span class="st">s+(</span><span class="sc">\\</span><span class="st">w+)&#39;</span>, <span class="st">&#39;</span><span class="sc">\\</span><span class="st">2 </span><span class="sc">\\</span><span class="st">1&#39;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;Tom Hanks&quot;   &quot;Ben Affleck&quot; &quot;Matt Damon&quot;</code></pre>
</div>
<div id="lookarounds" class="section level2" number="29.7">
<h2><span class="header-section-number">29.7</span> Lookarounds</h2>
<p><strong>Look-ahead</strong> and <strong>look-behinds</strong> are zero-width assertions in regex. They are used to match a pattern only if it is followed or preceded by another pattern, respectively. The pattern in the look-ahead or look-behind is not included in the match.</p>
<div id="lookahead" class="section level3" number="29.7.1">
<h3><span class="header-section-number">29.7.1</span> Lookahead</h3>
<p>A look-ahead is used to match a pattern only if it is followed by another pattern. <em>Positive Lookaheads</em> are written as <code>(?=...)</code>, where <code>...</code> is the pattern that must follow the match.</p>
<p>For example, the regex pattern <code>hello(?= world)</code> matches “hello” only if it is followed by ” world”. It matches “hello world” but not “hello there world” or “hello”.</p>
<p>Example</p>
<div class="sourceCode" id="cb1725"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1725-1"><a href="regex---a-quick-introduction.html#cb1725-1" tabindex="-1"></a>string <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;hello world&quot;</span>, <span class="st">&quot;hello there world&quot;</span>, <span class="st">&quot;hello&quot;</span>)</span>
<span id="cb1725-2"><a href="regex---a-quick-introduction.html#cb1725-2" tabindex="-1"></a><span class="fu">str_view</span>(string, <span class="st">&quot;hello(?= world)&quot;</span>, <span class="at">match =</span> <span class="cn">NA</span>)</span></code></pre></div>
<pre><code>## [1] │ &lt;hello&gt; world
## [2] │ hello there world
## [3] │ hello</code></pre>
<div class="sourceCode" id="cb1727"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1727-1"><a href="regex---a-quick-introduction.html#cb1727-1" tabindex="-1"></a><span class="co"># Note that &quot;world&quot; is not included in the match</span></span></code></pre></div>
</div>
<div id="lookbehind" class="section level3" number="29.7.2">
<h3><span class="header-section-number">29.7.2</span> Lookbehind</h3>
<p>A look-behind is used to match a pattern only if it is preceded by another pattern. Look-behinds are written as <code>(?&lt;=...)</code>, where <code>...</code> is the pattern that must precede the match.</p>
<p>For example, the regex pattern <code>(?&lt;=hello )world</code> matches “world” only if it is preceded by “hello”. It matches “hello world” but not “world hello” or “hello there world”.</p>
<p>Example</p>
<div class="sourceCode" id="cb1728"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1728-1"><a href="regex---a-quick-introduction.html#cb1728-1" tabindex="-1"></a>string <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;hello world&quot;</span>, <span class="st">&quot;world hello&quot;</span>, <span class="st">&quot;hello there world&quot;</span>)</span>
<span id="cb1728-2"><a href="regex---a-quick-introduction.html#cb1728-2" tabindex="-1"></a><span class="fu">str_view</span>(string, <span class="st">&quot;(?&lt;=hello )world&quot;</span>, <span class="at">match =</span> <span class="cn">NA</span>)</span></code></pre></div>
<pre><code>## [1] │ hello &lt;world&gt;
## [2] │ world hello
## [3] │ hello there world</code></pre>
</div>
<div id="negative-lookahead-and-lookbehinds" class="section level3" number="29.7.3">
<h3><span class="header-section-number">29.7.3</span> Negative Lookahead and Lookbehinds</h3>
<p>Negative look-ahead and negative look-behinds are used to match a pattern only if it is not followed or preceded by another pattern, respectively. Negative look-ahead and look-behinds are written as <code>(?!...)</code> and <code>(?&lt;!...)</code>, respectively.</p>
<p>For example, the regex pattern <code>hello(?! world)</code> matches “hello” only if it is not followed by ” world”. It matches “hello there” but not “hello world” or “hello world there”.</p>
<p>Example-</p>
<div class="sourceCode" id="cb1730"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1730-1"><a href="regex---a-quick-introduction.html#cb1730-1" tabindex="-1"></a>string <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;hello there&quot;</span>, <span class="st">&quot;hello world&quot;</span>, <span class="st">&quot;hello world there&quot;</span>)</span>
<span id="cb1730-2"><a href="regex---a-quick-introduction.html#cb1730-2" tabindex="-1"></a><span class="fu">str_view</span>(string, <span class="st">&quot;hello(?! world)&quot;</span>, <span class="at">match =</span> <span class="cn">NA</span>)</span></code></pre></div>
<pre><code>## [1] │ &lt;hello&gt; there
## [2] │ hello world
## [3] │ hello world there</code></pre>
<p>And the regex pattern <code>(?&lt;!hello )world</code> matches “world” only if it is not preceded by “hello”. It matches “world hello” and “hello there world” but not “hello world”.</p>
<div class="sourceCode" id="cb1732"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1732-1"><a href="regex---a-quick-introduction.html#cb1732-1" tabindex="-1"></a>string <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;hello world&quot;</span>, <span class="st">&quot;world hello&quot;</span>, <span class="st">&quot;hello there world&quot;</span>)</span>
<span id="cb1732-2"><a href="regex---a-quick-introduction.html#cb1732-2" tabindex="-1"></a><span class="fu">str_view</span>(string, <span class="st">&quot;(?&lt;!hello )world&quot;</span>, <span class="at">match =</span> <span class="cn">NA</span>)</span></code></pre></div>
<pre><code>## [1] │ hello world
## [2] │ &lt;world&gt; hello
## [3] │ hello there &lt;world&gt;</code></pre>
<p><em>While the difference between the look-ahead and look-behind may be subtle, yet these become clear when string/pattern replacement or extraction is required.</em></p>
<p>Examples-</p>
<div class="sourceCode" id="cb1734"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1734-1"><a href="regex---a-quick-introduction.html#cb1734-1" tabindex="-1"></a>string <span class="ot">&lt;-</span> <span class="st">&quot;I have 10 apples, 6 pineapples and 5 bananas&quot;</span></span>
<span id="cb1734-2"><a href="regex---a-quick-introduction.html#cb1734-2" tabindex="-1"></a></span>
<span id="cb1734-3"><a href="regex---a-quick-introduction.html#cb1734-3" tabindex="-1"></a><span class="co"># look-behind to match &quot;apples&quot; preceded by a digit and a space</span></span>
<span id="cb1734-4"><a href="regex---a-quick-introduction.html#cb1734-4" tabindex="-1"></a>pattern1 <span class="ot">&lt;-</span> <span class="st">&quot;(?&lt;=</span><span class="sc">\\</span><span class="st">d</span><span class="sc">\\</span><span class="st">s)apples&quot;</span>  </span>
<span id="cb1734-5"><a href="regex---a-quick-introduction.html#cb1734-5" tabindex="-1"></a></span>
<span id="cb1734-6"><a href="regex---a-quick-introduction.html#cb1734-6" tabindex="-1"></a><span class="co"># look-ahead to match count of apples</span></span>
<span id="cb1734-7"><a href="regex---a-quick-introduction.html#cb1734-7" tabindex="-1"></a>pattern2 <span class="ot">&lt;-</span> <span class="st">&quot;</span><span class="sc">\\</span><span class="st">d+(?=</span><span class="sc">\\</span><span class="st">sapple)&quot;</span>  </span>
<span id="cb1734-8"><a href="regex---a-quick-introduction.html#cb1734-8" tabindex="-1"></a></span>
<span id="cb1734-9"><a href="regex---a-quick-introduction.html#cb1734-9" tabindex="-1"></a><span class="fu">str_view</span>(<span class="at">string =</span> string, <span class="at">pattern =</span> pattern1, <span class="at">match =</span> <span class="cn">NA</span>)</span></code></pre></div>
<pre><code>## [1] │ I have 10 &lt;apples&gt;, 6 pineapples and 5 bananas</code></pre>
<div class="sourceCode" id="cb1736"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1736-1"><a href="regex---a-quick-introduction.html#cb1736-1" tabindex="-1"></a><span class="fu">str_view</span>(<span class="at">string =</span> string, <span class="at">pattern =</span> pattern2, <span class="at">match =</span> <span class="cn">NA</span>)</span></code></pre></div>
<pre><code>## [1] │ I have &lt;10&gt; apples, 6 pineapples and 5 bananas</code></pre>
</div>
</div>
<div id="comments" class="section level2" number="29.8">
<h2><span class="header-section-number">29.8</span> Comments</h2>
<div id="comments-within-regex" class="section level3" number="29.8.1">
<h3><span class="header-section-number">29.8.1</span> Comments within regex</h3>
<p>We can use the # character to add comments within a regex pattern. Any text following the <code>#</code> symbol on a line is ignored by the regex engine and treated as a comment. This can be useful for documenting your regex patterns or temporarily disabling parts of a pattern for testing or debugging. Example-</p>
<div class="sourceCode" id="cb1738"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1738-1"><a href="regex---a-quick-introduction.html#cb1738-1" tabindex="-1"></a><span class="fu">str_view</span>(<span class="fu">c</span>(<span class="st">&quot;xyz&quot;</span>,<span class="st">&quot;abc&quot;</span>), <span class="st">&quot;x(?#this is a comment)&quot;</span>, <span class="at">match =</span> <span class="cn">NA</span>)</span></code></pre></div>
<pre><code>## [1] │ &lt;x&gt;yz
## [2] │ abc</code></pre>
</div>
<div id="verbose-mode-multi-line-comments" class="section level3" number="29.8.2">
<h3><span class="header-section-number">29.8.2</span> Verbose Mode (multi-line comments)</h3>
<p>In regular expressions, verbose mode is a feature that allows you to write more readable and maintainable regex patterns by adding comments and white-space without affecting their behavior. To enable verbose mode, we can use the <code>(?x)</code> or <code>(?verbose)</code> modifier at the beginning of your regex pattern.</p>
<p>Example - Using this regex we can extract words that contain a vowel at third place.</p>
<div class="sourceCode" id="cb1740"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1740-1"><a href="regex---a-quick-introduction.html#cb1740-1" tabindex="-1"></a>string <span class="ot">&lt;-</span> <span class="st">&quot;The quick brown fox jumps over the lazy dog&quot;</span></span>
<span id="cb1740-2"><a href="regex---a-quick-introduction.html#cb1740-2" tabindex="-1"></a>pattern <span class="ot">&lt;-</span> <span class="st">&quot;(?x)      # Enable verbose mode</span></span>
<span id="cb1740-3"><a href="regex---a-quick-introduction.html#cb1740-3" tabindex="-1"></a><span class="st">            </span><span class="sc">\\</span><span class="st">b       # Match word boundary</span></span>
<span id="cb1740-4"><a href="regex---a-quick-introduction.html#cb1740-4" tabindex="-1"></a><span class="st">            </span><span class="sc">\\</span><span class="st">w{2}    # matches first two alphabets</span></span>
<span id="cb1740-5"><a href="regex---a-quick-introduction.html#cb1740-5" tabindex="-1"></a><span class="st">            [aeiou]   # Match a vowel</span></span>
<span id="cb1740-6"><a href="regex---a-quick-introduction.html#cb1740-6" tabindex="-1"></a><span class="st">            </span><span class="sc">\\</span><span class="st">w*      # Match optional word characters</span></span>
<span id="cb1740-7"><a href="regex---a-quick-introduction.html#cb1740-7" tabindex="-1"></a><span class="st">            </span><span class="sc">\\</span><span class="st">b       # Match word boundary&quot;</span></span>
<span id="cb1740-8"><a href="regex---a-quick-introduction.html#cb1740-8" tabindex="-1"></a><span class="fu">str_view</span>(string, pattern, <span class="at">match =</span> <span class="cn">NA</span>)</span></code></pre></div>
<pre><code>## [1] │ &lt;The&gt; &lt;quick&gt; &lt;brown&gt; fox jumps &lt;over&gt; &lt;the&gt; lazy dog</code></pre>
</div>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="35">
<li id="fn35"><p>Dont repeat yourself<a href="regex---a-quick-introduction.html#fnref35" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
  </main>

  <div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page">
      <h2>On this page</h2>
      <div id="book-on-this-page"></div>

      <div class="book-extra">
        <ul class="list-unstyled">
          <li><a id="book-source" href="#">View source <i class="fab fa-github"></i></a></li>
          <li><a id="book-edit" href="#">Edit this page <i class="fab fa-github"></i></a></li>
        </ul>
      </div>
    </nav>
  </div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5">
  <div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>R for Audit Analytics</strong>" was written by Anil Goyal. It was last built on 2024-11-29.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer>


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
<script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>

</html>
